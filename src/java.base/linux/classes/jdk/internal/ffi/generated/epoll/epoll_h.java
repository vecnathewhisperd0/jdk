/*
 * Copyright (c) 2024, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

// Generated by jextract

package jdk.internal.ffi.generated.epoll;

import jdk.internal.ffi.generated.BindingUtils;
import jdk.internal.ffi.util.FFMUtils;

import java.lang.invoke.*;
import java.lang.foreign.*;

@SuppressWarnings("restricted")
public class epoll_h {

    epoll_h() {
        // Should not be called directly
    }

    private static final int EPOLL_CTL_ADD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EPOLL_CTL_ADD 1
     * }
     */
    public static int EPOLL_CTL_ADD() {
        return EPOLL_CTL_ADD;
    }
    private static final int EPOLL_CTL_DEL = (int)2L;
    /**
     * {@snippet lang=c :
     * #define EPOLL_CTL_DEL 2
     * }
     */
    public static int EPOLL_CTL_DEL() {
        return EPOLL_CTL_DEL;
    }
    private static final int EPOLL_CTL_MOD = (int)3L;
    /**
     * {@snippet lang=c :
     * #define EPOLL_CTL_MOD 3
     * }
     */
    public static int EPOLL_CTL_MOD() {
        return EPOLL_CTL_MOD;
    }

    private static final int EPOLL_CLOEXEC = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.EPOLL_CLOEXEC = 524288
     * }
     */
    public static int EPOLL_CLOEXEC() {
        return EPOLL_CLOEXEC;
    }
    private static final int EPOLLIN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum EPOLL_EVENTS.EPOLLIN = 1
     * }
     */
    public static int EPOLLIN() {
        return EPOLLIN;
    }
    private static final int EPOLLOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum EPOLL_EVENTS.EPOLLOUT = 4
     * }
     */
    public static int EPOLLOUT() {
        return EPOLLOUT;
    }
    private static final int EPOLLONESHOT = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * enum EPOLL_EVENTS.EPOLLONESHOT = 1073741824
     * }
     */
    public static int EPOLLONESHOT() {
        return EPOLLONESHOT;
    }

    private static class epoll_create1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BindingUtils.C_INT,
            BindingUtils.C_INT
        );

        public static final MemorySegment ADDR = FFMUtils.findOrThrow("epoll_create1");

        // Note: Linker.Option.captureCallState was added manually after generation of binding classes
        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,
                Linker.Option.captureCallState("errno"));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int epoll_create1(int __flags)
     * }
     */
    public static FunctionDescriptor epoll_create1$descriptor() {
        return epoll_create1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int epoll_create1(int __flags)
     * }
     */
    public static MethodHandle epoll_create1$handle() {
        return epoll_create1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int epoll_create1(int __flags)
     * }
     */
    public static MemorySegment epoll_create1$address() {
        return epoll_create1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int epoll_create1(int __flags)
     * }
     */
    // errnoCaptureState was manually added to match the HANDLE modification
    public static int epoll_create1(MemorySegment errnoCaptureState, int __flags) {
        var mh$ = epoll_create1.HANDLE;
        try {
            if (FFMUtils.TRACE_DOWNCALLS) {
                FFMUtils.traceDowncall("epoll_create1", __flags);
            }
            return (int)mh$.invokeExact(errnoCaptureState, __flags);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class epoll_ctl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BindingUtils.C_INT,
            BindingUtils.C_INT,
            BindingUtils.C_INT,
            BindingUtils.C_INT,
            BindingUtils.C_POINTER
        );

        public static final MemorySegment ADDR = FFMUtils.findOrThrow("epoll_ctl");
        // Note: Linker.Option.captureCallState was added manually after generation of binding classes
        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,
                Linker.Option.captureCallState("errno"));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int epoll_ctl(int __epfd, int __op, int __fd, struct epoll_event *__event)
     * }
     */
    public static FunctionDescriptor epoll_ctl$descriptor() {
        return epoll_ctl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int epoll_ctl(int __epfd, int __op, int __fd, struct epoll_event *__event)
     * }
     */
    public static MethodHandle epoll_ctl$handle() {
        return epoll_ctl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int epoll_ctl(int __epfd, int __op, int __fd, struct epoll_event *__event)
     * }
     */
    public static MemorySegment epoll_ctl$address() {
        return epoll_ctl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int epoll_ctl(int __epfd, int __op, int __fd, struct epoll_event *__event)
     * }
     */
    // errnoCaptureState was manually added to match the HANDLE modification
    public static int epoll_ctl(int __epfd, int __op, int __fd, MemorySegment __event,
                                MemorySegment errnoCaptureState) {
        var mh$ = epoll_ctl.HANDLE;
        try {
            if (FFMUtils.TRACE_DOWNCALLS) {
                FFMUtils.traceDowncall("epoll_ctl", __epfd, __op, __fd, __event);
            }
            return (int)mh$.invokeExact(errnoCaptureState, __epfd, __op, __fd, __event);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class epoll_wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            BindingUtils.C_INT,
            BindingUtils.C_INT,
            BindingUtils.C_POINTER,
            BindingUtils.C_INT,
            BindingUtils.C_INT
        );

        public static final MemorySegment ADDR = FFMUtils.findOrThrow("epoll_wait");

        // Note: Linker.Option.captureCallState was added manually after generation of binding classes
        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC,
                Linker.Option.captureCallState("errno"));
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int epoll_wait(int __epfd, struct epoll_event *__events, int __maxevents, int __timeout)
     * }
     */
    public static FunctionDescriptor epoll_wait$descriptor() {
        return epoll_wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int epoll_wait(int __epfd, struct epoll_event *__events, int __maxevents, int __timeout)
     * }
     */
    public static MethodHandle epoll_wait$handle() {
        return epoll_wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int epoll_wait(int __epfd, struct epoll_event *__events, int __maxevents, int __timeout)
     * }
     */
    public static MemorySegment epoll_wait$address() {
        return epoll_wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int epoll_wait(int __epfd, struct epoll_event *__events, int __maxevents, int __timeout)
     * }
     */
    // errnoCaptureState was manually added to match the HANDLE modification
    public static int epoll_wait(int __epfd, MemorySegment __events, int __maxevents, int __timeout,
                                 MemorySegment errnoCaptureState) {
        var mh$ = epoll_wait.HANDLE;
        try {
            if (FFMUtils.TRACE_DOWNCALLS) {
                FFMUtils.traceDowncall("epoll_wait", __epfd, __events, __maxevents, __timeout);
            }
            return (int)mh$.invokeExact(errnoCaptureState, __epfd, __events, __maxevents, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

